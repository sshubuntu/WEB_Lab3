import px


def http_data(start_time: str, source_filter: str, destination_filter: str, num_head: int):

    df = px.DataFrame(table='http_events', start_time=start_time)

    df.node = df.ctx['node']
    df.pid = px.upid_to_pid(df.upid)
    df = add_source_dest_columns(df)
    df = add_source_dest_links(df, start_time)

    df = df[px.contains(df.source, source_filter)]
    df = df[px.contains(df.destination, destination_filter)]


    df = df.head(num_head)

    df = df['time_', 'source', 'destination', 'latency', 'major_version', 'req_path',
            'req_method', 'req_headers', 'req_body', 'req_body_size', 'resp_status',
            'resp_message', 'resp_headers', 'resp_body', 'resp_body_size']

    return df


def add_source_dest_columns(df):
    ''' Add source and destination columns for the HTTP request.

    HTTP requests are traced server-side (trace_role==2), unless the server is
    outside of the cluster in which case the request is traced client-side (trace_role==1).

    When trace_role==2, the HTTP request source is the remote_addr column
    and destination is the pod column. When trace_role==1, the HTTP request
    source is the pod column and the destination is the remote_addr column.

    Input DataFrame must contain trace_role, upid, remote_addr columns.
    '''
    df.pod = df.ctx['pod']
    df.namespace = df.ctx['namespace']

    df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
    df.is_ra_pod = df.ra_pod != ''
    df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

    df.is_server_tracing = df.trace_role == 2
    df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
    df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

    df.source = px.select(df.is_server_tracing, df.ra_name, df.pod)
    df.destination = px.select(df.is_server_tracing, df.pod, df.ra_name)

    df = df[df.source != '']
    df = df[df.destination != '']

    df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])

    return df


def add_source_dest_links(df, start_time: str):
    ''' Modifies the source and destination columns to display deeplinks in the UI.
    Clicking on a pod name in either column will run the px/pod script for that pod.
    Clicking on an IP address, will run the px/ip script showing all network connections
    to/from that IP address.

    Input DataFrame must contain source, destination, is_source_pod_type,
    is_dest_pod_type, and namespace columns.
    '''

    df.src_pod_link = px.script_reference(df.source, 'px/pod', {
        'start_time': start_time,
        'pod': df.source
    })
    df.src_link = px.script_reference(df.source, 'px/ip', {
        'start_time': start_time,
        'ip': df.source,
    })
    df.source = px.select(df.is_source_pod_type, df.src_pod_link, df.src_link)

    df.dest_pod_link = px.script_reference(df.destination, 'px/pod', {
        'start_time': start_time,
        'pod': df.destination
    })
    df.dest_link = px.script_reference(df.destination, 'px/ip', {
        'start_time': start_time,
        'ip': df.destination,
    })
    df.destination = px.select(df.is_dest_pod_type, df.dest_pod_link, df.dest_link)

    df = df.drop(['src_pod_link', 'src_link', 'is_source_pod_type', 'dest_pod_link',
                  'dest_link', 'is_dest_pod_type'])

    return df


def network_traffic_timeseries(start_time: str, source_filter: str, destination_filter: str, num_head: int):
    df = http_data(start_time, source_filter, destination_filter, num_head)
    ns_per_s = 1000 * 1000 * 100
    window_ns = px.DurationNanos(10 * ns_per_s)
    df.timestamp = px.bin(df.time_, window_ns)
    df.latency_get = df['latency']

    df.time_ = df.timestamp
    df = df.drop('timestamp')
    return df